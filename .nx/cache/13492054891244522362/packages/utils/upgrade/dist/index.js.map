{"version":3,"file":"index.js","sources":["../src/modules/timer/timer.ts","../src/modules/timer/constants.ts","../src/modules/format/formats.ts","../src/modules/npm/constants.ts","../src/modules/version/types.ts","../src/modules/version/semver.ts","../src/modules/version/range.ts","../src/modules/npm/package.ts","../src/modules/file-scanner/scanner.ts","../src/modules/runner/runner.ts","../src/modules/runner/code/code.ts","../src/modules/json/transform-api.ts","../src/modules/json/file.ts","../src/modules/runner/json/transform.ts","../src/modules/runner/json/json.ts","../src/modules/project/constants.ts","../src/modules/project/project.ts","../src/modules/project/utils.ts","../src/modules/error/utils.ts","../src/modules/codemod/constants.ts","../src/modules/codemod/codemod.ts","../src/modules/codemod-repository/constants.ts","../src/modules/codemod-repository/repository.ts","../src/modules/codemod-runner/codemod-runner.ts","../src/modules/upgrader/upgrader.ts","../src/modules/upgrader/constants.ts","../src/modules/requirement/requirement.ts","../src/tasks/upgrade/requirements/major.ts","../src/tasks/upgrade/requirements/common.ts","../src/tasks/upgrade/prompts/latest.ts","../src/tasks/upgrade/upgrade.ts","../src/tasks/codemods/utils.ts","../src/tasks/codemods/run-codemods.ts","../src/tasks/codemods/list-codemods.ts","../src/modules/logger/logger.ts","../src/modules/report/report.ts"],"sourcesContent":["import type { Timer as TimerInterface, TimeInterval } from './types';\n\nexport class Timer implements TimerInterface {\n  private interval!: TimeInterval;\n\n  constructor() {\n    this.reset();\n  }\n\n  get elapsedMs() {\n    const { start, end } = this.interval;\n\n    return end ? end - start : Date.now() - start;\n  }\n\n  get end() {\n    return this.interval.end;\n  }\n\n  get start() {\n    return this.interval.start;\n  }\n\n  stop() {\n    this.interval.end = Date.now();\n\n    return this.elapsedMs;\n  }\n\n  reset() {\n    this.interval = { start: Date.now(), end: null };\n\n    return this;\n  }\n}\n\nexport const timerFactory = () => new Timer();\n","export const ONE_SECOND_MS = 1000;\n","import CliTable3 from 'cli-table3';\nimport chalk from 'chalk';\n\nimport { constants as timerConstants } from '../timer';\n\nimport type { AppProject, PluginProject, ProjectType } from '../project';\nimport type { Codemod } from '../codemod';\nimport type { Version } from '../version';\nimport type { Report } from '../report';\n\nexport const path = (path: string) => chalk.blue(path);\n\nexport const version = (version: Version.LiteralVersion | Version.SemVer) => {\n  return chalk.italic.yellow(`v${version}`);\n};\n\nexport const codemodUID = (uid: string) => {\n  return chalk.bold.cyan(uid);\n};\n\nexport const projectDetails = (project: AppProject | PluginProject) => {\n  return `Project: TYPE=${projectType(project.type)}; CWD=${path(project.cwd)}; PATHS=${project.paths.map(path)}`;\n};\n\nexport const projectType = (type: ProjectType) => chalk.cyan(type);\n\nexport const versionRange = (range: Version.Range) => chalk.italic.yellow(range.raw);\n\nexport const transform = (transformFilePath: string) => chalk.cyan(transformFilePath);\n\nexport const highlight = (arg: unknown) => chalk.bold.underline(arg);\n\nexport const upgradeStep = (text: string, step: [current: number, total: number]) => {\n  return chalk.bold(`(${step[0]}/${step[1]}) ${text}...`);\n};\n\nexport const reports = (reports: Report.CodemodReport[]) => {\n  const rows = reports.map(({ codemod, report }, i) => {\n    const fIndex = chalk.grey(i);\n    const fVersion = chalk.magenta(codemod.version);\n    const fKind = chalk.yellow(codemod.kind);\n    const fFormattedTransformPath = chalk.cyan(codemod.format());\n    const fTimeElapsed =\n      i === 0\n        ? `${report.timeElapsed}s ${chalk.dim.italic('(cold start)')}`\n        : `${report.timeElapsed}s`;\n    const fAffected = report.ok > 0 ? chalk.green(report.ok) : chalk.grey(0);\n    const fUnchanged = report.ok === 0 ? chalk.red(report.nochange) : chalk.grey(report.nochange);\n\n    return [fIndex, fVersion, fKind, fFormattedTransformPath, fAffected, fUnchanged, fTimeElapsed];\n  });\n\n  const table = new CliTable3({\n    style: { compact: true },\n    head: [\n      chalk.bold.grey('N°'),\n      chalk.bold.magenta('Version'),\n      chalk.bold.yellow('Kind'),\n      chalk.bold.cyan('Name'),\n      chalk.bold.green('Affected'),\n      chalk.bold.red('Unchanged'),\n      chalk.bold.blue('Duration'),\n    ],\n  });\n\n  table.push(...rows);\n\n  return table.toString();\n};\n\nexport const codemodList = (codemods: Codemod.List) => {\n  type Row = [index: string, version: string, kind: string, name: string, uid: string];\n\n  const rows = codemods.map<Row>((codemod, index) => {\n    const fIndex = chalk.grey(index);\n    const fVersion = chalk.magenta(codemod.version);\n    const fKind = chalk.yellow(codemod.kind);\n    const fName = chalk.blue(codemod.format());\n    const fUID = codemodUID(codemod.uid);\n\n    return [fIndex, fVersion, fKind, fName, fUID] satisfies Row;\n  });\n\n  const table = new CliTable3({\n    style: { compact: true },\n    head: [\n      chalk.bold.grey('N°'),\n      chalk.bold.magenta('Version'),\n      chalk.bold.yellow('Kind'),\n      chalk.bold.blue('Name'),\n      chalk.bold.cyan('UID'),\n    ],\n  });\n\n  table.push(...rows);\n\n  return table.toString();\n};\n\nexport const durationMs = (elapsedMs: number) => {\n  const elapsedSeconds = (elapsedMs / timerConstants.ONE_SECOND_MS).toFixed(3);\n\n  return `${elapsedSeconds}s`;\n};\n","export const NPM_REGISTRY_URL = 'https://registry.npmjs.org';\n","export type Version = number;\n\nexport type LiteralVersion =\n  | `${Version}`\n  | `${Version}.${Version}`\n  | `${Version}.${Version}.${Version}`;\n\nexport type LiteralSemVer = `${Version}.${Version}.${Version}`;\n\nexport type { SemVer, Range } from 'semver';\n\nexport enum ReleaseType {\n  // Classic\n  Major = 'major',\n  Minor = 'minor',\n  Patch = 'patch',\n  // Other\n  Latest = 'latest',\n}\n","import semver from 'semver';\n\nimport * as Version from './types';\n\nexport const semVerFactory = (version: string): Version.SemVer => {\n  return new semver.SemVer(version);\n};\n\nexport const isLiteralSemVer = (str: string): str is Version.LiteralSemVer => {\n  const tokens = str.split('.');\n\n  return (\n    tokens.length === 3 &&\n    tokens.every((token) => !Number.isNaN(+token) && Number.isInteger(+token))\n  );\n};\n\nexport const isValidSemVer = (str: string) => semver.valid(str) !== null;\n\nexport const isSemverInstance = (value: unknown): value is semver.SemVer => {\n  return value instanceof semver.SemVer;\n};\n\nexport const isSemVerReleaseType = (str: string): str is Version.ReleaseType => {\n  return Object.values(Version.ReleaseType).includes(str as Version.ReleaseType);\n};\n","import semver from 'semver';\n\nimport * as Version from './types';\nimport { isSemverInstance, isSemVerReleaseType, semVerFactory } from './semver';\n\nexport const rangeFactory = (range: string): Version.Range => {\n  return new semver.Range(range);\n};\n\nexport const rangeFromReleaseType = (current: Version.SemVer, identifier: Version.ReleaseType) => {\n  switch (identifier) {\n    case Version.ReleaseType.Latest: {\n      // Match anything greater than the current version\n      return rangeFactory(`>${current.raw}`);\n    }\n    case Version.ReleaseType.Major: {\n      // For example, 4.15.4 returns 5.0.0\n      const nextMajor = semVerFactory(current.raw).inc('major');\n\n      // Using only the major version as the upper limit allows any minor,\n      // patch, or build version to be taken in the range.\n      //\n      // For example, if the current version is \"4.15.4\", incrementing the\n      // major version would result in \"5.0.0\".\n      // The generated rule is \">4.15.4 <=5\", allowing any version\n      // greater than \"4.15.4\" but less than \"6.0.0-0\".\n      return rangeFactory(`>${current.raw} <=${nextMajor.major}`);\n    }\n    case Version.ReleaseType.Minor: {\n      // For example, 4.15.4 returns 5.0.0\n      const nextMajor = semVerFactory(current.raw).inc('major');\n\n      // Using the <major>.<minor>.<patch> version as the upper limit allows any minor,\n      // patch, or build versions to be taken in the range.\n      //\n      // For example, if the current version is \"4.15.4\", incrementing the\n      // major version would result in \"5.0.0\".\n      // The generated rule is \">4.15.4 <5.0.0\", allowing any version\n      // greater than \"4.15.4\" but less than \"5.0.0\".\n      return rangeFactory(`>${current.raw} <${nextMajor.raw}`);\n    }\n    case Version.ReleaseType.Patch: {\n      // For example, 4.15.4 returns 4.16.0\n      const nextMinor = semVerFactory(current.raw).inc('minor');\n\n      // Using only the minor version as the upper limit allows any patch\n      // or build versions to be taken in the range.\n      //\n      // For example, if the current version is \"4.15.4\", incrementing the\n      // minor version would result in \"4.16.0\".\n      // The generated rule is \">4.15.4 <4.16.0\", allowing any version\n      // greater than \"4.15.4\" but less than \"4.16.0\".\n      return rangeFactory(`>${current.raw} <${nextMinor.raw}`);\n    }\n    default: {\n      throw new Error('Not implemented');\n    }\n  }\n};\n\nexport const rangeFromVersions = (\n  currentVersion: Version.SemVer,\n  target: Version.ReleaseType | Version.SemVer\n) => {\n  if (isSemverInstance(target)) {\n    return rangeFactory(`>${currentVersion.raw} <=${target.raw}`);\n  }\n\n  if (isSemVerReleaseType(target)) {\n    return rangeFromReleaseType(currentVersion, target);\n  }\n\n  throw new Error(`Invalid target set: ${target}`); // TODO: better errors\n};\n\nexport const isValidStringifiedRange = (str: string) => semver.validRange(str) !== null;\n\nexport const isRangeInstance = (range: unknown): range is semver.Range => {\n  return range instanceof semver.Range;\n};\n","import assert from 'node:assert';\nimport semver from 'semver';\n\nimport * as constants from './constants';\nimport { isLiteralSemVer } from '../version';\n\nimport type { Package as PackageInterface, NPMPackage, NPMPackageVersion } from './types';\nimport type { Version } from '../version';\n\nexport class Package implements PackageInterface {\n  name: string;\n\n  packageURL: string;\n\n  private npmPackage: NPMPackage | null;\n\n  constructor(name: string) {\n    this.name = name;\n    this.packageURL = `${constants.NPM_REGISTRY_URL}/${name}`;\n    this.npmPackage = null;\n  }\n\n  get isLoaded() {\n    return this.npmPackage !== null;\n  }\n\n  private assertPackageIsLoaded(npmPackage: NPMPackage | null): asserts npmPackage is NPMPackage {\n    assert(this.isLoaded, 'The package is not loaded yet');\n  }\n\n  getVersionsDict() {\n    this.assertPackageIsLoaded(this.npmPackage);\n\n    return this.npmPackage.versions;\n  }\n\n  getVersionsAsList() {\n    this.assertPackageIsLoaded(this.npmPackage);\n\n    return Object.values(this.npmPackage.versions);\n  }\n\n  findVersionsInRange(range: Version.Range) {\n    const versions = this.getVersionsAsList();\n\n    return (\n      versions\n        // Only select versions matching the upgrade range\n        .filter((v) => range.test(v.version))\n        // Only select supported version format (x.x.x)\n        .filter((v) => isLiteralSemVer(v.version))\n        // Sort in ascending order\n        .sort((v1, v2) => semver.compare(v1.version, v2.version))\n    );\n  }\n\n  findVersion(version: Version.SemVer): NPMPackageVersion | undefined {\n    const versions = this.getVersionsAsList();\n\n    return versions.find((npmVersion) => semver.eq(npmVersion.version, version));\n  }\n\n  async refresh() {\n    const response = await fetch(this.packageURL);\n\n    // TODO: Use a validation library to make sure the response structure is correct\n    assert(response.ok, `Request failed for ${this.packageURL}`);\n\n    this.npmPackage = await response.json();\n\n    return this;\n  }\n\n  versionExists(version: Version.SemVer) {\n    return this.findVersion(version) !== undefined;\n  }\n}\n\nexport const npmPackageFactory = (name: string) => new Package(name);\n","import path from 'node:path';\nimport fastglob from 'fast-glob';\n\nimport type { FileScanner as FileScannerInterface } from './types';\n\nexport class FileScanner implements FileScannerInterface {\n  public cwd: string;\n\n  constructor(cwd: string) {\n    this.cwd = cwd;\n  }\n\n  scan(patterns: string[]) {\n    // we use fastglob instead of glob because it supports negation patterns\n    const filenames = fastglob.sync(patterns, {\n      cwd: this.cwd,\n    });\n\n    // Resolve the full paths for every filename\n    return filenames.map((filename) => path.join(this.cwd, filename));\n  }\n}\n\nexport const fileScannerFactory = (cwd: string) => new FileScanner(cwd);\n","import type { Codemod } from '../codemod';\n\nimport type { Runner as RunnerInterface, RunnerConfiguration, RunnerFunction } from './types';\n\nexport abstract class AbstractRunner<TConfig extends RunnerConfiguration>\n  implements RunnerInterface<TConfig>\n{\n  abstract runner: RunnerFunction<TConfig>;\n\n  paths: string[];\n\n  configuration: TConfig;\n\n  constructor(paths: string[], configuration: TConfig) {\n    this.paths = paths;\n    this.configuration = configuration;\n  }\n\n  async run(codemod: Codemod.Codemod, configuration?: TConfig) {\n    const isValidCodemod = this.valid(codemod);\n\n    if (!isValidCodemod) {\n      throw new Error(`Invalid codemod provided to the runner: ${codemod.filename}`);\n    }\n\n    const runConfiguration: TConfig = { ...this.configuration, ...configuration };\n\n    return this.runner(codemod.path, this.paths, runConfiguration);\n  }\n\n  abstract valid(codemod: Codemod.Codemod): boolean;\n}\n","import { run as jscodeshift } from 'jscodeshift/src/Runner';\n\nimport { AbstractRunner } from '../runner';\n\nimport type { Codemod } from '../../codemod';\nimport type { CodeRunnerConfiguration } from './types';\n\nexport class CodeRunner extends AbstractRunner<CodeRunnerConfiguration> {\n  runner = jscodeshift;\n\n  valid(codemod: Codemod.Codemod): boolean {\n    return codemod.kind === 'code';\n  }\n}\n\nexport const codeRunnerFactory = (paths: string[], configuration: CodeRunnerConfiguration) => {\n  return new CodeRunner(paths, configuration);\n};\n","import { cloneDeep, get, has, set, merge, omit } from 'lodash/fp';\n\nimport type { Utils } from '@strapi/types';\n\nimport type { JSONTransformAPI as JSONTransformAPIInterface } from './types';\n\nexport class JSONTransformAPI implements JSONTransformAPIInterface {\n  private json: Utils.JSONObject;\n\n  constructor(json: Utils.JSONObject) {\n    this.json = cloneDeep(json);\n  }\n\n  get<T extends Utils.JSONValue>(path: string): T | undefined;\n  get<T extends Utils.JSONValue>(path: string, defaultValue: T): T;\n  get<T extends Utils.JSONValue>(path?: string, defaultValue?: T) {\n    if (!path) {\n      return this.root() as T;\n    }\n\n    return cloneDeep(get(path, this.json) ?? defaultValue) as T;\n  }\n\n  has(path: string) {\n    return has(path, this.json);\n  }\n\n  merge(other: Utils.JSONObject) {\n    this.json = merge(other, this.json);\n\n    return this;\n  }\n\n  root(): Utils.JSONObject {\n    return cloneDeep(this.json);\n  }\n\n  set(path: string, value: Utils.JSONValue) {\n    this.json = set(path, value, this.json);\n\n    return this;\n  }\n\n  remove(path: string) {\n    this.json = omit(path, this.json);\n    return this;\n  }\n}\n\nexport const createJSONTransformAPI = (object: Utils.JSONObject) => new JSONTransformAPI(object);\n","import fse from 'fs-extra';\n\nimport type { Utils } from '@strapi/types';\n\nexport const readJSON = async (path: string): Promise<Utils.JSONValue> => {\n  const buffer = await fse.readFile(path);\n\n  return JSON.parse(buffer.toString());\n};\n\nexport const saveJSON = async (path: string, json: Utils.JSONValue): Promise<void> => {\n  const jsonAsString = `${JSON.stringify(json, null, 2)}\\n`;\n\n  await fse.writeFile(path, jsonAsString);\n};\n","/* eslint-disable @typescript-eslint/no-var-requires */\n\nimport assert from 'node:assert';\nimport { isEqual } from 'lodash/fp';\nimport { register } from 'esbuild-register/dist/node';\n\nimport { createJSONTransformAPI, readJSON, saveJSON } from '../../json';\n\nimport type { Report } from '../../report';\n\nimport type { JSONRunnerConfiguration, JSONSourceFile, JSONTransformParams } from './types';\n\nexport const transformJSON = async (\n  codemodPath: string,\n  paths: string[],\n  config: JSONRunnerConfiguration\n): Promise<Report.Report> => {\n  const { dry } = config;\n  const startTime = process.hrtime();\n\n  const report: Report.Report = {\n    ok: 0,\n    nochange: 0,\n    skip: 0,\n    error: 0,\n    timeElapsed: '',\n    stats: {},\n  };\n\n  /**\n   * Why do we need to include node_modules (hookIgnoreNodeModules) and specify a matcher (hookMatcher) to esbuild?\n   *\n   * When using tools like npx or dlx, the execution context is different from when running the program in a local\n   * project. npx and dlx run the commands in a temporary installation, which is isolated from local project files.\n   *\n   * When hookIgnoreNodeModules is not specified (or set to true), esbuild-register instructs\n   * Pirates (https://github.com/danez/pirates) to not transpile any files that come from node_modules.\n   *\n   * Now, when using npx or dlx to run a script, its location can be seen as \"external\" because it's not part of\n   * the temporary environment where npx or dlx execute. Therefore, it's considered to be part of node_modules.\n   *\n   * Due to this, if hookIgnoreNodeModules is set to true or left unspecified,\n   * esbuild-register won't try to compile them upon require.\n   *\n   * hookMatcher is added to make sure we're not matching anything else than our codemod in external directories.\n   */\n  const esbuildOptions = {\n    extensions: ['.js', '.mjs', '.ts'],\n    hookIgnoreNodeModules: false,\n    hookMatcher: isEqual(codemodPath),\n  };\n  const { unregister } = register(esbuildOptions);\n\n  const module = require(codemodPath);\n\n  unregister();\n\n  const codemod = typeof module.default === 'function' ? module.default : module;\n\n  assert(typeof codemod === 'function', `Codemod must be a function. Found ${typeof codemod}`);\n\n  for (const path of paths) {\n    try {\n      const json = await readJSON(path);\n\n      // Make sure the JSON value is a JSON object\n      assert(typeof json === 'object' && !Array.isArray(json) && json !== null);\n\n      // TODO: Optimize the API to limit parse/stringify operations\n      const file: JSONSourceFile = { path, json };\n      const params: JSONTransformParams = { cwd: config.cwd, json: createJSONTransformAPI };\n\n      const out = await codemod(file, params);\n\n      if (out === undefined) {\n        report.error += 1;\n      }\n      // If the json object has modifications\n      else if (!isEqual(json, out)) {\n        if (!dry) {\n          await saveJSON(path, out);\n        }\n        report.ok += 1;\n      }\n      // No changes\n      else {\n        report.nochange += 1;\n      }\n    } catch {\n      report.error += 1;\n    }\n  }\n\n  const endTime = process.hrtime(startTime);\n  report.timeElapsed = (endTime[0] + endTime[1] / 1e9).toFixed(3);\n\n  return report;\n};\n","import { AbstractRunner } from '../runner';\n\nimport { transformJSON } from './transform';\n\nimport type { Codemod } from '../../codemod';\nimport type { JSONRunnerConfiguration } from './types';\n\nexport class JSONRunner extends AbstractRunner<JSONRunnerConfiguration> {\n  runner = transformJSON;\n\n  valid(codemod: Codemod.Codemod): boolean {\n    return codemod.kind === 'json';\n  }\n}\n\nexport const jsonRunnerFactory = (paths: string[], configuration: JSONRunnerConfiguration) => {\n  return new JSONRunner(paths, configuration);\n};\n","export const PROJECT_PACKAGE_JSON = 'package.json';\n\nexport const PROJECT_APP_ALLOWED_ROOT_PATHS = ['src', 'config', 'public'];\n\nexport const PROJECT_PLUGIN_ALLOWED_ROOT_PATHS = ['admin', 'server'];\n\nexport const PROJECT_PLUGIN_ROOT_FILES = ['strapi-admin.js', 'strapi-server.js'];\n\nexport const PROJECT_CODE_EXTENSIONS = [\n  // Source files\n  'js',\n  'mjs',\n  'ts',\n  // React files\n  'jsx',\n  'tsx',\n];\n\nexport const PROJECT_JSON_EXTENSIONS = ['json'];\n\nexport const PROJECT_ALLOWED_EXTENSIONS = [...PROJECT_CODE_EXTENSIONS, ...PROJECT_JSON_EXTENSIONS];\n\nexport const SCOPED_STRAPI_PACKAGE_PREFIX = '@strapi/';\n\nexport const STRAPI_DEPENDENCY_NAME = `${SCOPED_STRAPI_PACKAGE_PREFIX}strapi`;\n","import path from 'node:path';\nimport assert from 'node:assert';\nimport fse from 'fs-extra';\nimport semver from 'semver';\n\nimport { semVerFactory, isLiteralSemVer, isValidSemVer } from '../version';\nimport { fileScannerFactory } from '../file-scanner';\nimport { codeRunnerFactory } from '../runner/code';\nimport { jsonRunnerFactory } from '../runner/json';\nimport * as constants from './constants';\n\nimport type { Version } from '../version';\nimport type { Codemod } from '../codemod';\nimport type { Report } from '../report';\nimport type {\n  FileExtension,\n  MinimalPackageJSON,\n  ProjectConfig,\n  ProjectType,\n  RunCodemodsOptions,\n} from './types';\n\nexport class Project {\n  public cwd: string;\n\n  // The following properties are assigned during the .refresh() call in the constructor.\n\n  public files!: string[];\n\n  public packageJSONPath!: string;\n\n  public packageJSON!: MinimalPackageJSON;\n\n  public readonly paths: string[];\n\n  constructor(cwd: string, config: ProjectConfig) {\n    if (!fse.pathExistsSync(cwd)) {\n      throw new Error(`ENOENT: no such file or directory, access '${cwd}'`);\n    }\n\n    this.cwd = cwd;\n    this.paths = config.paths;\n\n    this.refresh();\n  }\n\n  getFilesByExtensions(extensions: FileExtension[]) {\n    return this.files.filter((filePath) => {\n      const fileExtension = path.extname(filePath) as FileExtension;\n\n      return extensions.includes(fileExtension);\n    });\n  }\n\n  refresh() {\n    this.refreshPackageJSON();\n    this.refreshProjectFiles();\n\n    return this;\n  }\n\n  async runCodemods(codemods: Codemod.List, options: RunCodemodsOptions) {\n    const runners = this.createProjectCodemodsRunners(options.dry);\n    const reports: Report.CodemodReport[] = [];\n\n    for (const codemod of codemods) {\n      for (const runner of runners) {\n        if (runner.valid(codemod)) {\n          const report = await runner.run(codemod);\n          reports.push({ codemod, report });\n        }\n      }\n    }\n\n    return reports;\n  }\n\n  private createProjectCodemodsRunners(dry: boolean = false) {\n    const jsonExtensions = constants.PROJECT_JSON_EXTENSIONS.map<FileExtension>((ext) => `.${ext}`);\n    const codeExtensions = constants.PROJECT_CODE_EXTENSIONS.map<FileExtension>((ext) => `.${ext}`);\n\n    const jsonFiles = this.getFilesByExtensions(jsonExtensions);\n    const codeFiles = this.getFilesByExtensions(codeExtensions);\n\n    const codeRunner = codeRunnerFactory(codeFiles, {\n      dry,\n      parser: 'ts',\n      runInBand: true,\n      babel: true,\n      extensions: constants.PROJECT_CODE_EXTENSIONS.join(','),\n      // Don't output any log coming from the runner\n      print: false,\n      silent: true,\n      verbose: 0,\n    });\n\n    const jsonRunner = jsonRunnerFactory(jsonFiles, { dry, cwd: this.cwd });\n\n    return [codeRunner, jsonRunner] as const;\n  }\n\n  private refreshPackageJSON(): void {\n    const packageJSONPath = path.join(this.cwd, constants.PROJECT_PACKAGE_JSON);\n\n    try {\n      fse.accessSync(packageJSONPath);\n    } catch {\n      throw new Error(`Could not find a ${constants.PROJECT_PACKAGE_JSON} file in ${this.cwd}`);\n    }\n\n    const packageJSONBuffer = fse.readFileSync(packageJSONPath);\n\n    this.packageJSONPath = packageJSONPath;\n    this.packageJSON = JSON.parse(packageJSONBuffer.toString());\n  }\n\n  private refreshProjectFiles(): void {\n    const scanner = fileScannerFactory(this.cwd);\n\n    this.files = scanner.scan(this.paths);\n  }\n}\n\nexport class AppProject extends Project {\n  public strapiVersion!: Version.SemVer;\n\n  readonly type = 'application' as const satisfies ProjectType;\n\n  /**\n   * Returns an array of allowed file paths for a Strapi application\n   *\n   * The resulting paths include app default files and the root package.json file.\n   */\n  private static get paths() {\n    const allowedRootPaths = formatGlobCollectionPattern(constants.PROJECT_APP_ALLOWED_ROOT_PATHS);\n    const allowedExtensions = formatGlobCollectionPattern(constants.PROJECT_ALLOWED_EXTENSIONS);\n\n    return [\n      // App default files\n      `./${allowedRootPaths}/**/*.${allowedExtensions}`,\n      `!./**/node_modules/**/*`,\n      `!./**/dist/**/*`,\n      // Root package.json file\n      constants.PROJECT_PACKAGE_JSON,\n    ];\n  }\n\n  constructor(cwd: string) {\n    super(cwd, { paths: AppProject.paths });\n    this.refreshStrapiVersion();\n  }\n\n  refresh() {\n    super.refresh();\n    this.refreshStrapiVersion();\n    return this;\n  }\n\n  private refreshStrapiVersion(): void {\n    this.strapiVersion =\n      // First try to get the strapi version from the package.json dependencies\n      this.findStrapiVersionFromProjectPackageJSON() ??\n      // If the version found is not a valid SemVer, get the Strapi version from the installed package\n      this.findLocallyInstalledStrapiVersion();\n  }\n\n  private findStrapiVersionFromProjectPackageJSON(): Version.SemVer | undefined {\n    const projectName = this.packageJSON.name;\n    const version = this.packageJSON.dependencies?.[constants.STRAPI_DEPENDENCY_NAME];\n\n    if (version === undefined) {\n      throw new Error(\n        `No version of ${constants.STRAPI_DEPENDENCY_NAME} was found in ${projectName}. Are you in a valid Strapi project?`\n      );\n    }\n\n    const isValidSemVer = isLiteralSemVer(version) && semver.valid(version) === version;\n\n    // We return undefined only if a strapi/strapi version is found, but it's not semver compliant\n    return isValidSemVer ? semVerFactory(version) : undefined;\n  }\n\n  private findLocallyInstalledStrapiVersion(): Version.SemVer {\n    const packageSearchText = `${constants.STRAPI_DEPENDENCY_NAME}/package.json`;\n\n    let strapiPackageJSONPath: string;\n    let strapiPackageJSON: MinimalPackageJSON;\n\n    try {\n      strapiPackageJSONPath = require.resolve(packageSearchText, { paths: [this.cwd] });\n      strapiPackageJSON = require(strapiPackageJSONPath);\n\n      assert(typeof strapiPackageJSON === 'object');\n    } catch {\n      throw new Error(\n        `Cannot resolve module \"${constants.STRAPI_DEPENDENCY_NAME}\" from paths [${this.cwd}]`\n      );\n    }\n\n    const strapiVersion = strapiPackageJSON.version;\n\n    if (!isValidSemVer(strapiVersion)) {\n      throw new Error(\n        `Invalid ${constants.STRAPI_DEPENDENCY_NAME} version found in ${strapiPackageJSONPath} (${strapiVersion})`\n      );\n    }\n\n    return semVerFactory(strapiVersion);\n  }\n}\n\nconst formatGlobCollectionPattern = (collection: string[]): string => {\n  assert(\n    collection.length > 0,\n    'Invalid pattern provided, the given collection needs at least 1 element'\n  );\n\n  return collection.length === 1 ? collection[0] : `{${collection}}`;\n};\n\nexport class PluginProject extends Project {\n  readonly type = 'plugin' as const satisfies ProjectType;\n\n  /**\n   * Returns an array of allowed file paths for a Strapi plugin\n   *\n   * The resulting paths include plugin default files, the root package.json file, and plugin-specific files.\n   */\n  private static get paths() {\n    const allowedRootPaths = formatGlobCollectionPattern(\n      constants.PROJECT_PLUGIN_ALLOWED_ROOT_PATHS\n    );\n    const allowedExtensions = formatGlobCollectionPattern(constants.PROJECT_ALLOWED_EXTENSIONS);\n\n    return [\n      // Plugin default files\n      `./${allowedRootPaths}/**/*.${allowedExtensions}`,\n      `!./**/node_modules/**/*`,\n      `!./**/dist/**/*`,\n      // Root package.json file\n      constants.PROJECT_PACKAGE_JSON,\n      // Plugin root files\n      ...constants.PROJECT_PLUGIN_ROOT_FILES,\n    ];\n  }\n\n  constructor(cwd: string) {\n    super(cwd, { paths: PluginProject.paths });\n  }\n}\n\nconst isPlugin = (cwd: string) => {\n  const packageJSONPath = path.join(cwd, constants.PROJECT_PACKAGE_JSON);\n\n  try {\n    fse.accessSync(packageJSONPath);\n  } catch {\n    throw new Error(`Could not find a ${constants.PROJECT_PACKAGE_JSON} file in ${cwd}`);\n  }\n\n  const packageJSONBuffer = fse.readFileSync(packageJSONPath);\n\n  const packageJSON = JSON.parse(packageJSONBuffer.toString());\n\n  return packageJSON?.strapi?.kind === 'plugin';\n};\n\n// TODO: make this async so we can use async file methods\nexport const projectFactory = (cwd: string) => {\n  fse.accessSync(cwd);\n\n  return isPlugin(cwd) ? new PluginProject(cwd) : new AppProject(cwd);\n};\n","import { AppProject, PluginProject } from './project';\n\nexport const isPluginProject = (project: unknown): project is PluginProject => {\n  return project instanceof PluginProject;\n};\n\nexport function assertPluginProject(project: unknown): asserts project is PluginProject {\n  if (!isPluginProject(project)) {\n    throw new Error('Project is not a plugin');\n  }\n}\n\nexport const isApplicationProject = (project: unknown): project is AppProject => {\n  return project instanceof AppProject;\n};\n\nexport function assertAppProject(project: unknown): asserts project is AppProject {\n  if (!isApplicationProject(project)) {\n    throw new Error('Project is not an application');\n  }\n}\n","import type { Version } from '../version';\n\nexport class UnexpectedError extends Error {\n  constructor() {\n    super('Unexpected Error');\n  }\n}\n\nexport class NPMCandidateNotFoundError extends Error {\n  target: Version.SemVer | Version.Range | Version.ReleaseType;\n\n  constructor(\n    target: Version.SemVer | Version.Range | Version.ReleaseType,\n    message: string = `Couldn't find a valid NPM candidate for \"${target}\"`\n  ) {\n    super(message);\n\n    this.target = target;\n  }\n}\n\nexport class AbortedError extends Error {\n  constructor(message: string = 'Upgrade aborted') {\n    super(message);\n  }\n}\n\nexport const unknownToError = (e: unknown): Error => {\n  if (e instanceof Error) {\n    return e;\n  }\n\n  if (typeof e === 'string') {\n    return new Error(e);\n  }\n\n  return new UnexpectedError();\n};\n","export const CODEMOD_CODE_SUFFIX = 'code';\n\nexport const CODEMOD_JSON_SUFFIX = 'json';\n\nexport const CODEMOD_ALLOWED_SUFFIXES = [CODEMOD_CODE_SUFFIX, CODEMOD_JSON_SUFFIX];\n\nexport const CODEMOD_EXTENSION = 'ts';\n\nexport const CODEMOD_FILE_REGEXP = new RegExp(\n  `^.+[.](${CODEMOD_ALLOWED_SUFFIXES.join('|')})[.]${CODEMOD_EXTENSION}$`\n);\n","import path from 'node:path';\n\nimport * as constants from './constants';\n\nimport type { Codemod as CodemodInterface, FormatOptions, Kind, UID } from './types';\nimport type { Version } from '../version';\n\ntype CreateCodemodPayload = Pick<\n  CodemodInterface,\n  'kind' | 'version' | 'baseDirectory' | 'filename'\n>;\n\nexport class Codemod implements CodemodInterface {\n  uid: UID;\n\n  kind: Kind;\n\n  version: Version.SemVer;\n\n  baseDirectory: string;\n\n  filename: string;\n\n  path: string;\n\n  constructor(options: CreateCodemodPayload) {\n    this.kind = options.kind;\n    this.version = options.version;\n    this.baseDirectory = options.baseDirectory;\n    this.filename = options.filename;\n\n    this.path = path.join(this.baseDirectory, this.version.raw, this.filename);\n    this.uid = this.createUID();\n  }\n\n  private createUID(): UID {\n    const name = this.format({ stripExtension: true, stripKind: true, stripHyphens: false });\n    const kind = this.kind;\n    const version = this.version.raw as Version.LiteralSemVer;\n\n    return `${version}-${name}-${kind}`;\n  }\n\n  format(options?: FormatOptions) {\n    const { stripExtension = true, stripKind = true, stripHyphens = true } = options ?? {};\n\n    let formatted = this.filename;\n\n    if (stripExtension) {\n      formatted = formatted.replace(new RegExp(`\\\\.${constants.CODEMOD_EXTENSION}$`, 'i'), '');\n    }\n\n    if (stripKind) {\n      formatted = formatted\n        .replace(`.${constants.CODEMOD_CODE_SUFFIX}`, '')\n        .replace(`.${constants.CODEMOD_JSON_SUFFIX}`, '');\n    }\n\n    if (stripHyphens) {\n      formatted = formatted.replaceAll('-', ' ');\n    }\n\n    return formatted;\n  }\n}\n\nexport const codemodFactory = (options: CreateCodemodPayload) => new Codemod(options);\n","import path from 'node:path';\n\nexport const INTERNAL_CODEMODS_DIRECTORY = path.join(\n  __dirname, // upgrade/dist\n  '..', // upgrade\n  'resources', // upgrade/resources\n  'codemods' // upgrade/resources/codemods\n);\n","import assert from 'node:assert';\nimport fse from 'fs-extra';\nimport semver from 'semver';\nimport path from 'node:path';\n\nimport { codemodFactory, constants } from '../codemod';\nimport { isRangeInstance, semVerFactory } from '../version';\n\nimport { INTERNAL_CODEMODS_DIRECTORY } from './constants';\n\nimport type { Codemod } from '../codemod';\nimport type { Version } from '../version';\n\nimport type { CodemodRepository as CodemodRepositoryInterface, FindQuery } from './types';\n\nexport class CodemodRepository implements CodemodRepositoryInterface {\n  private groups: Record<Version.LiteralSemVer, Codemod.Codemod[]>;\n\n  private versions: Version.SemVer[];\n\n  public cwd: string;\n\n  constructor(cwd: string) {\n    assert(fse.existsSync(cwd), `Invalid codemods directory provided \"${cwd}\"`);\n\n    this.cwd = cwd;\n\n    this.groups = {};\n    this.versions = [];\n  }\n\n  refresh() {\n    this.refreshAvailableVersions();\n    this.refreshAvailableFiles();\n\n    return this;\n  }\n\n  count(version: Version.SemVer) {\n    return this.findByVersion(version).length;\n  }\n\n  versionExists(version: Version.SemVer) {\n    return version.raw in this.groups;\n  }\n\n  has(uid: string) {\n    const result = this.find({ uids: [uid] });\n\n    if (result.length !== 1) {\n      return false;\n    }\n\n    const { codemods } = result[0];\n\n    return codemods.length === 1 && codemods[0].uid === uid;\n  }\n\n  find(q: FindQuery) {\n    const entries = Object.entries(this.groups) as Array<[Version.LiteralSemVer, Codemod.List]>;\n\n    return (\n      entries\n        // Filter by range if provided in the query\n        .filter(maybeFilterByRange)\n        // Transform version/codemods tuples into regular objects\n        .map<Codemod.VersionedCollection>(([version, codemods]) => ({\n          version: semVerFactory(version),\n          // Filter by UID if provided in the query\n          codemods: codemods.filter(maybeFilterByUIDs),\n        }))\n        // Only return groups with at least 1 codemod\n        .filter(({ codemods }) => codemods.length > 0)\n    );\n\n    function maybeFilterByRange([version]: [Version.LiteralSemVer, Codemod.List]) {\n      if (!isRangeInstance(q.range)) {\n        return true;\n      }\n\n      return q.range.test(version);\n    }\n\n    function maybeFilterByUIDs(codemod: Codemod.Codemod) {\n      if (q.uids === undefined) {\n        return true;\n      }\n\n      return q.uids.includes(codemod.uid);\n    }\n  }\n\n  findByVersion(version: Version.SemVer) {\n    const literalVersion = version.raw as Version.LiteralSemVer;\n    const codemods = this.groups[literalVersion];\n\n    return codemods ?? [];\n  }\n\n  findAll() {\n    const entries = Object.entries(this.groups);\n\n    return entries.map<Codemod.VersionedCollection>(([version, codemods]) => ({\n      version: semVerFactory(version),\n      codemods,\n    }));\n  }\n\n  private refreshAvailableVersions() {\n    this.versions = fse\n      .readdirSync(this.cwd) // Only keep root directories\n      .filter((filename) => fse.statSync(path.join(this.cwd, filename)).isDirectory())\n      // Paths should be valid semver\n      .filter((filename): filename is Version.LiteralSemVer => semver.valid(filename) !== null)\n      // Transform files names to SemVer instances\n      .map<Version.SemVer>((version) => semVerFactory(version))\n      // Sort versions in ascending order\n      .sort(semver.compare);\n\n    return this;\n  }\n\n  private refreshAvailableFiles() {\n    this.groups = {};\n\n    for (const version of this.versions) {\n      this.refreshAvailableFilesForVersion(version);\n    }\n  }\n\n  private refreshAvailableFilesForVersion(version: Version.SemVer) {\n    const literalVersion = version.raw as Version.LiteralSemVer;\n    const versionDirectory = path.join(this.cwd, literalVersion);\n\n    // Ignore obsolete versions\n    if (!fse.existsSync(versionDirectory)) {\n      return;\n    }\n\n    this.groups[literalVersion] = fse\n      .readdirSync(versionDirectory)\n      // Make sure the filenames are valid codemod files\n      .filter((filename) => fse.statSync(path.join(versionDirectory, filename)).isFile())\n      .filter((filename) => constants.CODEMOD_FILE_REGEXP.test(filename))\n      // Transform the filenames into Codemod instances\n      .map((filename) => {\n        const kind = parseCodemodKindFromFilename(filename);\n        const baseDirectory = this.cwd;\n\n        return codemodFactory({ kind, baseDirectory, version, filename });\n      });\n  }\n}\n\nexport const parseCodemodKindFromFilename = (filename: string): Codemod.Kind => {\n  const kind = filename.split('.').at(-2) as Codemod.Kind | undefined;\n\n  assert(kind !== undefined);\n  assert(constants.CODEMOD_ALLOWED_SUFFIXES.includes(kind));\n\n  return kind;\n};\n\nexport const codemodRepositoryFactory = (cwd: string = INTERNAL_CODEMODS_DIRECTORY) => {\n  return new CodemodRepository(cwd);\n};\n","import { groupBy, size } from 'lodash/fp';\n\nimport {\n  codemodRepositoryFactory,\n  constants as codemodRepositoryConstants,\n} from '../codemod-repository';\nimport { unknownToError } from '../error';\nimport { semVerFactory } from '../version';\nimport * as f from '../format';\n\nimport type { Codemod } from '../codemod';\nimport type { Logger } from '../logger';\nimport type { Project } from '../project';\nimport type { UpgradeReport } from '../upgrader';\nimport type { CodemodRunnerInterface, CodemodRunnerReport, SelectCodemodsCallback } from './types';\nimport type { Version } from '../version';\n\nexport class CodemodRunner implements CodemodRunnerInterface {\n  private readonly project: Project;\n\n  private range: Version.Range;\n\n  private isDry: boolean;\n\n  private logger: Logger | null;\n\n  private selectCodemodsCallback: SelectCodemodsCallback | null;\n\n  constructor(project: Project, range: Version.Range) {\n    this.project = project;\n    this.range = range;\n\n    this.isDry = false;\n\n    this.logger = null;\n    this.selectCodemodsCallback = null;\n  }\n\n  setRange(range: Version.Range) {\n    this.range = range;\n    return this;\n  }\n\n  setLogger(logger: Logger) {\n    this.logger = logger;\n    return this;\n  }\n\n  onSelectCodemods(callback: SelectCodemodsCallback | null) {\n    this.selectCodemodsCallback = callback;\n    return this;\n  }\n\n  dry(enabled: boolean = true) {\n    this.isDry = enabled;\n    return this;\n  }\n\n  private createRepository(codemodsDirectory?: string) {\n    const repository = codemodRepositoryFactory(\n      codemodsDirectory ?? codemodRepositoryConstants.INTERNAL_CODEMODS_DIRECTORY\n    );\n\n    // Make sure we have access to the latest snapshots of codemods on the system\n    repository.refresh();\n\n    return repository;\n  }\n\n  private async safeRunAndReport(codemods: Codemod.List) {\n    if (this.isDry) {\n      this.logger?.warn?.(\n        'Running the codemods in dry mode. No files will be modified during the process.'\n      );\n    }\n\n    try {\n      const reports = await this.project.runCodemods(codemods, { dry: this.isDry });\n\n      this.logger?.raw?.(f.reports(reports));\n\n      if (!this.isDry) {\n        const nbAffectedTotal = reports\n          .flatMap((report) => report.report.ok)\n          .reduce((acc, nb) => acc + nb, 0);\n\n        this.logger?.debug?.(\n          `Successfully ran ${f.highlight(codemods.length)} codemod(s), ${f.highlight(nbAffectedTotal)} change(s) have been detected`\n        );\n      }\n\n      return successReport();\n    } catch (e: unknown) {\n      return erroredReport(unknownToError(e));\n    }\n  }\n\n  async runByUID(uid: string, codemodsDirectory?: string): Promise<CodemodRunnerReport> {\n    const repository = this.createRepository(codemodsDirectory);\n\n    if (!repository.has(uid)) {\n      throw new Error(`Unknown codemod UID provided: ${uid}`);\n    }\n\n    // Note: Ignore the range when running with a UID\n    const codemods = repository.find({ uids: [uid] }).flatMap(({ codemods }) => codemods);\n\n    return this.safeRunAndReport(codemods);\n  }\n\n  async run(codemodsDirectory?: string): Promise<CodemodRunnerReport> {\n    const repository = this.createRepository(codemodsDirectory);\n\n    // Find codemods matching the given range\n    const codemodsInRange = repository.find({ range: this.range });\n\n    // If a selection callback is set, use it, else keep every codemods found\n    const selectedCodemods = this.selectCodemodsCallback\n      ? await this.selectCodemodsCallback(codemodsInRange)\n      : codemodsInRange;\n\n    // If no codemods have been selected (either manually or automatically)\n    // Then ignore and return a successful report\n    if (selectedCodemods.length === 0) {\n      this.logger?.debug?.(`Found no codemods to run for ${f.versionRange(this.range)}`);\n      return successReport();\n    }\n\n    // Flatten the collection to a single list of codemods, the original list should already be sorted by version\n    const codemods = selectedCodemods.flatMap(({ codemods }) => codemods);\n\n    // Log (debug) the codemods by version\n    const codemodsByVersion = groupBy('version', codemods);\n    const fRange = f.versionRange(this.range);\n\n    this.logger?.debug?.(\n      `Found ${f.highlight(codemods.length)} codemods for ${f.highlight(size(codemodsByVersion))} version(s) using ${fRange}`\n    );\n\n    for (const [version, codemods] of Object.entries(codemodsByVersion)) {\n      this.logger?.debug?.(`- ${f.version(semVerFactory(version))} (${codemods.length})`);\n    }\n\n    return this.safeRunAndReport(codemods);\n  }\n}\n\nexport const codemodRunnerFactory = (project: Project, range: Version.Range) => {\n  return new CodemodRunner(project, range);\n};\n\nconst successReport = (): UpgradeReport => ({ success: true, error: null });\nconst erroredReport = (error: Error): UpgradeReport => ({ success: false, error });\n","import chalk from 'chalk';\nimport semver from 'semver';\nimport { packageManager } from '@strapi/utils';\n\nimport { createJSONTransformAPI, saveJSON } from '../json';\nimport { constants as projectConstants } from '../project';\nimport {\n  isSemverInstance,\n  isSemVerReleaseType,\n  isValidSemVer,\n  rangeFromVersions,\n  semVerFactory,\n} from '../version';\nimport { NPMCandidateNotFoundError, unknownToError } from '../error';\nimport * as f from '../format';\nimport { codemodRunnerFactory } from '../codemod-runner';\n\nimport type { Upgrader as UpgraderInterface, UpgradeReport } from './types';\nimport type { Version } from '../version';\nimport type { Logger } from '../logger';\nimport type { Requirement } from '../requirement';\nimport type { NPM } from '../npm';\nimport type { AppProject } from '../project';\nimport type { ConfirmationCallback } from '../common/types';\n\ntype DependenciesEntries = Array<[name: string, version: Version.SemVer]>;\n\nexport class Upgrader implements UpgraderInterface {\n  private readonly project: AppProject;\n\n  private readonly npmPackage: NPM.Package;\n\n  private target: Version.SemVer;\n\n  private codemodsTarget!: Version.SemVer;\n\n  private isDry: boolean;\n\n  private logger: Logger | null;\n\n  private requirements: Requirement.Requirement[];\n\n  private confirmationCallback: ConfirmationCallback | null;\n\n  constructor(project: AppProject, target: Version.SemVer, npmPackage: NPM.Package) {\n    this.project = project;\n    this.npmPackage = npmPackage;\n\n    this.target = target;\n    this.syncCodemodsTarget();\n\n    this.isDry = false;\n\n    this.requirements = [];\n\n    this.logger = null;\n    this.confirmationCallback = null;\n  }\n\n  getNPMPackage(): NPM.Package {\n    return this.npmPackage;\n  }\n\n  getProject(): AppProject {\n    return this.project;\n  }\n\n  getTarget(): Version.SemVer {\n    return semVerFactory(this.target.raw);\n  }\n\n  setRequirements(requirements: Requirement.Requirement[]) {\n    this.requirements = requirements;\n    return this;\n  }\n\n  setTarget(target: Version.SemVer) {\n    this.target = target;\n    return this;\n  }\n\n  syncCodemodsTarget() {\n    // Extract the <major>.<minor>.<patch> version from the target and assign it to the codemods target\n    //\n    // This is useful when dealing with alphas, betas or release candidates:\n    // e.g. \"5.0.0-beta.951\" becomes \"5.0.0\"\n    //\n    // For experimental versions (e.g. \"0.0.0-experimental.hex\"), it is necessary to\n    // override the codemods target manually in order to run the appropriate ones.\n    this.codemodsTarget = semVerFactory(\n      `${this.target.major}.${this.target.minor}.${this.target.patch}`\n    );\n\n    this.logger?.debug?.(\n      `The codemods target has been synced with the upgrade target. The codemod runner will now look for ${f.version(\n        this.codemodsTarget\n      )}`\n    );\n\n    return this;\n  }\n\n  overrideCodemodsTarget(target: Version.SemVer) {\n    this.codemodsTarget = target;\n\n    this.logger?.debug?.(\n      `Overriding the codemods target. The codemod runner will now look for ${f.version(target)}`\n    );\n\n    return this;\n  }\n\n  setLogger(logger: Logger) {\n    this.logger = logger;\n    return this;\n  }\n\n  onConfirm(callback: ConfirmationCallback | null) {\n    this.confirmationCallback = callback;\n    return this;\n  }\n\n  dry(enabled: boolean = true) {\n    this.isDry = enabled;\n    return this;\n  }\n\n  addRequirement(requirement: Requirement.Requirement) {\n    this.requirements.push(requirement);\n\n    const fRequired = requirement.isRequired ? '(required)' : '(optional)';\n    this.logger?.debug?.(\n      `Added a new requirement to the upgrade: ${f.highlight(requirement.name)} ${fRequired}`\n    );\n\n    return this;\n  }\n\n  async upgrade(): Promise<UpgradeReport> {\n    this.logger?.info?.(\n      `Upgrading from ${f.version(this.project.strapiVersion)} to ${f.version(this.target)}`\n    );\n\n    if (this.isDry) {\n      this.logger?.warn?.(\n        'Running the upgrade in dry mode. No files will be modified during the process.'\n      );\n    }\n\n    const range = rangeFromVersions(this.project.strapiVersion, this.target);\n    const codemodsRange = rangeFromVersions(this.project.strapiVersion, this.codemodsTarget);\n\n    const npmVersionsMatches = this.npmPackage?.findVersionsInRange(range) ?? [];\n\n    this.logger?.debug?.(\n      `Found ${f.highlight(npmVersionsMatches.length)} versions satisfying ${f.versionRange(range)}`\n    );\n\n    try {\n      this.logger?.info?.(f.upgradeStep('Checking requirement', [1, 4]));\n      await this.checkRequirements(this.requirements, {\n        npmVersionsMatches,\n        project: this.project,\n        target: this.target,\n      });\n\n      this.logger?.info?.(f.upgradeStep('Applying the latest code modifications', [2, 4]));\n      await this.runCodemods(codemodsRange);\n\n      // We need to refresh the project files to make sure we have\n      // the latest version of each file (including package.json) for the next steps\n      this.logger?.debug?.('Refreshing project information...');\n      this.project.refresh();\n\n      this.logger?.info?.(f.upgradeStep('Upgrading Strapi dependencies', [3, 4]));\n      await this.updateDependencies();\n\n      this.logger?.info?.(f.upgradeStep('Installing dependencies', [4, 4]));\n      await this.installDependencies();\n    } catch (e) {\n      return erroredReport(unknownToError(e));\n    }\n\n    return successReport();\n  }\n\n  async confirm(message: string): Promise<boolean> {\n    if (typeof this.confirmationCallback !== 'function') {\n      return true;\n    }\n\n    return this.confirmationCallback(message);\n  }\n\n  private async checkRequirements(\n    requirements: Requirement.Requirement[],\n    context: Requirement.TestContext\n  ) {\n    for (const requirement of requirements) {\n      const { pass, error } = await requirement.test(context);\n\n      if (pass) {\n        await this.onSuccessfulRequirement(requirement, context);\n      } else {\n        await this.onFailedRequirement(requirement, error);\n      }\n    }\n  }\n\n  private async onSuccessfulRequirement(\n    requirement: Requirement.Requirement,\n    context: Requirement.TestContext\n  ): Promise<void> {\n    const hasChildren = requirement.children.length > 0;\n\n    if (hasChildren) {\n      await this.checkRequirements(requirement.children, context);\n    }\n  }\n\n  private async onFailedRequirement(\n    requirement: Requirement.Requirement,\n    originalError: Error\n  ): Promise<void> {\n    const errorMessage = `Requirement failed: ${originalError.message} (${f.highlight(\n      requirement.name\n    )})`;\n    const warningMessage = originalError.message;\n    const confirmationMessage = `Ignore optional requirement \"${f.highlight(requirement.name)}\" ?`;\n\n    const error = new Error(errorMessage);\n\n    if (requirement.isRequired) {\n      throw error;\n    }\n\n    this.logger?.warn?.(warningMessage);\n\n    const response = await this.confirmationCallback?.(confirmationMessage);\n\n    if (!response) {\n      throw error;\n    }\n  }\n\n  private async updateDependencies(): Promise<void> {\n    const { packageJSON, packageJSONPath } = this.project;\n\n    const json = createJSONTransformAPI(packageJSON);\n\n    const dependencies = json.get<Record<string, string>>('dependencies', {});\n    const strapiDependencies = this.getScopedStrapiDependencies(dependencies);\n\n    this.logger?.debug?.(\n      `Found ${f.highlight(strapiDependencies.length)} dependency(ies) to update`\n    );\n    strapiDependencies.forEach((dependency) =>\n      this.logger?.debug?.(`- ${dependency[0]} (${dependency[1]} -> ${this.target})`)\n    );\n\n    if (strapiDependencies.length === 0) {\n      return;\n    }\n\n    strapiDependencies.forEach(([name]) => json.set(`dependencies.${name}`, this.target.raw));\n\n    const updatedPackageJSON = json.root();\n\n    if (this.isDry) {\n      this.logger?.debug?.(`Skipping dependencies update (${chalk.italic('dry mode')})`);\n      return;\n    }\n\n    await saveJSON(packageJSONPath, updatedPackageJSON);\n  }\n\n  private getScopedStrapiDependencies(dependencies: Record<string, string>): DependenciesEntries {\n    const { strapiVersion } = this.project;\n\n    const strapiDependencies: DependenciesEntries = [];\n\n    // Find all @strapi/* packages matching the current Strapi version\n    for (const [name, version] of Object.entries(dependencies)) {\n      const isScopedStrapiPackage = name.startsWith(projectConstants.SCOPED_STRAPI_PACKAGE_PREFIX);\n      const isOnCurrentStrapiVersion = isValidSemVer(version) && version === strapiVersion.raw;\n\n      if (isScopedStrapiPackage && isOnCurrentStrapiVersion) {\n        strapiDependencies.push([name, semVerFactory(version)]);\n      }\n    }\n\n    return strapiDependencies;\n  }\n\n  private async installDependencies(): Promise<void> {\n    const projectPath = this.project.cwd;\n\n    const packageManagerName = await packageManager.getPreferred(projectPath);\n\n    this.logger?.debug?.(`Using ${f.highlight(packageManagerName)} as package manager`);\n\n    if (this.isDry) {\n      this.logger?.debug?.(`Skipping dependencies installation (${chalk.italic('dry mode')})`);\n      return;\n    }\n\n    await packageManager.installDependencies(projectPath, packageManagerName, {\n      stdout: this.logger?.stdout,\n      stderr: this.logger?.stderr,\n    });\n  }\n\n  private async runCodemods(range: Version.Range): Promise<void> {\n    const codemodRunner = codemodRunnerFactory(this.project, range);\n\n    codemodRunner.dry(this.isDry);\n\n    if (this.logger) {\n      codemodRunner.setLogger(this.logger);\n    }\n\n    await codemodRunner.run();\n  }\n}\n\n/**\n * Resolves the NPM target version based on the given project, target, and NPM package.\n * If target is a SemVer, it directly finds it. If it's a release type (major, minor, patch),\n * it calculates the range of versions for this release type and returns the latest version within this range.\n */\nconst resolveNPMTarget = (\n  project: AppProject,\n  target: Version.ReleaseType | Version.SemVer,\n  npmPackage: NPM.Package\n): NPM.NPMPackageVersion => {\n  // Semver\n  if (isSemverInstance(target)) {\n    const version = npmPackage.findVersion(target);\n\n    if (!version) {\n      throw new NPMCandidateNotFoundError(target);\n    }\n\n    return version;\n  }\n\n  // Release Types\n  if (isSemVerReleaseType(target)) {\n    const range = rangeFromVersions(project.strapiVersion, target);\n    const npmVersionsMatches = npmPackage.findVersionsInRange(range);\n\n    // The targeted version is the latest one that matches the given range\n    const version = npmVersionsMatches.at(-1);\n\n    if (!version) {\n      throw new NPMCandidateNotFoundError(range, `The project is already up-to-date (${target})`);\n    }\n\n    return version;\n  }\n\n  throw new NPMCandidateNotFoundError(target);\n};\n\nexport const upgraderFactory = (\n  project: AppProject,\n  target: Version.ReleaseType | Version.SemVer,\n  npmPackage: NPM.Package\n) => {\n  const npmTarget = resolveNPMTarget(project, target, npmPackage);\n  const semverTarget = semVerFactory(npmTarget.version);\n\n  if (semver.eq(semverTarget, project.strapiVersion)) {\n    throw new Error(`The project is already using v${semverTarget}`);\n  }\n\n  return new Upgrader(project, semverTarget, npmPackage);\n};\n\nconst successReport = (): UpgradeReport => ({ success: true, error: null });\nconst erroredReport = (error: Error): UpgradeReport => ({ success: false, error });\n","export const STRAPI_PACKAGE_NAME = '@strapi/strapi';\n","import type {\n  Requirement as RequirementInterface,\n  RequirementTestCallback,\n  TestContext,\n  TestResult,\n} from './types';\n\nexport class Requirement implements RequirementInterface {\n  readonly isRequired: boolean;\n\n  readonly name: string;\n\n  readonly testCallback: RequirementTestCallback | null;\n\n  children: RequirementInterface[];\n\n  constructor(name: string, testCallback: RequirementTestCallback | null, isRequired?: boolean) {\n    this.name = name;\n    this.testCallback = testCallback;\n    this.isRequired = isRequired ?? true;\n    this.children = [];\n  }\n\n  setChildren(children: RequirementInterface[]) {\n    this.children = children;\n    return this;\n  }\n\n  addChild(child: RequirementInterface) {\n    this.children.push(child);\n    return this;\n  }\n\n  asOptional() {\n    const newInstance = requirementFactory(this.name, this.testCallback, false);\n\n    newInstance.setChildren(this.children);\n\n    return newInstance;\n  }\n\n  asRequired() {\n    const newInstance = requirementFactory(this.name, this.testCallback, true);\n\n    newInstance.setChildren(this.children);\n\n    return newInstance;\n  }\n\n  async test(context: TestContext) {\n    try {\n      await this.testCallback?.(context);\n      return ok();\n    } catch (e) {\n      if (e instanceof Error) {\n        return errored(e);\n      }\n\n      if (typeof e === 'string') {\n        return errored(new Error(e));\n      }\n\n      return errored(new Error('Unknown error'));\n    }\n  }\n}\n\nconst ok = (): TestResult => ({ pass: true, error: null });\n\nconst errored = (error: Error): TestResult => ({ pass: false, error });\n\nexport const requirementFactory = (\n  name: string,\n  testCallback: RequirementTestCallback | null,\n  isRequired?: boolean\n) => new Requirement(name, testCallback, isRequired);\n","import { requirementFactory } from '../../../modules/requirement';\nimport { semVerFactory } from '../../../modules/version';\n\nexport const REQUIRE_AVAILABLE_NEXT_MAJOR = requirementFactory(\n  'REQUIRE_AVAILABLE_NEXT_MAJOR',\n  (context) => {\n    const { project, target } = context;\n\n    const currentMajor = project.strapiVersion.major;\n    const targetedMajor = target.major;\n\n    if (targetedMajor === currentMajor) {\n      throw new Error(`You're already on the latest major version (v${currentMajor})`);\n    }\n  }\n);\n\nexport const REQUIRE_LATEST_FOR_CURRENT_MAJOR = requirementFactory(\n  'REQUIRE_LATEST_FOR_CURRENT_MAJOR',\n  (context) => {\n    const { project, target, npmVersionsMatches } = context;\n    const { major: currentMajor } = project.strapiVersion;\n\n    const invalidMatches = npmVersionsMatches.filter(\n      (match) => semVerFactory(match.version).major === currentMajor\n    );\n\n    if (invalidMatches.length > 0) {\n      const invalidVersions = invalidMatches.map((match) => match.version);\n      const invalidVersionsCount = invalidVersions.length;\n\n      throw new Error(\n        `Doing a major upgrade requires to be on the latest v${currentMajor} version, but found ${invalidVersionsCount} versions between the current one and ${target}. Please upgrade to ${invalidVersions.at(-1)} and try again.`\n      );\n    }\n  }\n);\n","import simpleGit from 'simple-git';\n\nimport { requirementFactory } from '../../../modules/requirement';\n\nexport const REQUIRE_GIT_CLEAN_REPOSITORY = requirementFactory(\n  'REQUIRE_GIT_CLEAN_REPOSITORY',\n  async (context) => {\n    const git = simpleGit({ baseDir: context.project.cwd });\n\n    const status = await git.status();\n\n    if (!status.isClean()) {\n      throw new Error(\n        'Repository is not clean. Please commit or stash any changes before upgrading'\n      );\n    }\n  }\n);\n\nexport const REQUIRE_GIT_REPOSITORY = requirementFactory(\n  'REQUIRE_GIT_REPOSITORY',\n  async (context) => {\n    const git = simpleGit({ baseDir: context.project.cwd });\n\n    const isRepo = await git.checkIsRepo();\n\n    if (!isRepo) {\n      throw new Error('Not a git repository (or any of the parent directories)');\n    }\n  }\n).addChild(REQUIRE_GIT_CLEAN_REPOSITORY.asOptional());\n\nexport const REQUIRE_GIT_INSTALLED = requirementFactory(\n  'REQUIRE_GIT_INSTALLED',\n  async (context) => {\n    const git = simpleGit({ baseDir: context.project.cwd });\n\n    try {\n      await git.version();\n    } catch {\n      throw new Error('Git is not installed');\n    }\n  }\n).addChild(REQUIRE_GIT_REPOSITORY.asOptional());\n\nexport const REQUIRE_GIT = requirementFactory('REQUIRE_GIT', null).addChild(\n  REQUIRE_GIT_INSTALLED.asOptional()\n);\n","import { AbortedError } from '../../../modules/error';\nimport * as f from '../../../modules/format';\n\nimport { rangeFactory, semVerFactory, Version } from '../../../modules/version';\n\nimport type { Upgrader } from '../../../modules/upgrader';\nimport type { UpgradeOptions } from '../types';\n\n/**\n * Handles the upgrade prompts when using the latest tag.\n *\n * - checks if an upgrade involves a major bump, warning and asking for user confirmation before proceeding\n */\nexport const latest = async (upgrader: Upgrader, options: UpgradeOptions) => {\n  // Exit if the upgrade target isn't the latest tag\n  if (options.target !== Version.ReleaseType.Latest) {\n    return;\n  }\n\n  // Retrieve utilities from the upgrader instance\n  const npmPackage = upgrader.getNPMPackage();\n  const target = upgrader.getTarget();\n  const project = upgrader.getProject();\n\n  const { strapiVersion: current } = project;\n\n  // Pre-formatted strings used in logs\n  const fTargetMajor = f.highlight(`v${target.major}`);\n  const fCurrentMajor = f.highlight(`v${current.major}`);\n\n  const fTarget = f.version(target);\n  const fCurrent = f.version(current);\n\n  // Flags\n  const isMajorUpgrade = target.major > current.major;\n\n  // Handle potential major upgrade, warns, and asks for confirmation to proceed\n  if (isMajorUpgrade) {\n    options.logger.warn(\n      `Detected a major upgrade for the \"${f.highlight(Version.ReleaseType.Latest)}\" tag: ${fCurrent} > ${fTarget}`\n    );\n\n    // Find the latest release in between the current one and the next major\n    const newerPackageRelease = npmPackage\n      .findVersionsInRange(rangeFactory(`>${current.raw} <${target.major}`))\n      .at(-1);\n\n    // If the project isn't on the latest version for the current major, emit a warning\n    if (newerPackageRelease) {\n      const fLatest = f.version(semVerFactory(newerPackageRelease.version));\n      options.logger.warn(\n        `It's recommended to first upgrade to the latest version of ${fCurrentMajor} (${fLatest}) before upgrading to ${fTargetMajor}.`\n      );\n    }\n\n    const proceedAnyway = await upgrader.confirm(`I know what I'm doing. Proceed anyway!`);\n\n    if (!proceedAnyway) {\n      throw new AbortedError();\n    }\n  }\n};\n","import path from 'node:path';\n\nimport * as f from '../../modules/format';\nimport { npmPackageFactory } from '../../modules/npm';\nimport { isApplicationProject, projectFactory } from '../../modules/project';\nimport { timerFactory } from '../../modules/timer';\nimport { constants as upgraderConstants, upgraderFactory } from '../../modules/upgrader';\nimport { Version } from '../../modules/version';\n\nimport * as requirements from './requirements';\nimport * as prompts from './prompts';\n\nimport type { UpgradeOptions } from './types';\nimport type { Upgrader } from '../../modules/upgrader';\n\nexport const upgrade = async (options: UpgradeOptions) => {\n  const timer = timerFactory();\n  const { logger, codemodsTarget } = options;\n\n  // Resolves the correct working directory based on the given input\n  const cwd = path.resolve(options.cwd ?? process.cwd());\n\n  const project = projectFactory(cwd);\n\n  logger.debug(f.projectDetails(project));\n\n  if (!isApplicationProject(project)) {\n    throw new Error(\n      `The \"${options.target}\" upgrade can only be run on a Strapi project; for plugins, please use \"codemods\".`\n    );\n  }\n\n  logger.debug(\n    `Application: VERSION=${f.version(project.packageJSON.version as Version.LiteralVersion)}; STRAPI_VERSION=${f.version(project.strapiVersion)}`\n  );\n\n  const npmPackage = npmPackageFactory(upgraderConstants.STRAPI_PACKAGE_NAME);\n\n  // Load all available versions from the NPM registry\n  await npmPackage.refresh();\n\n  // Initialize the upgrade instance\n  // Throws during initialization if the provided target is incompatible with the current version\n  const upgrader = upgraderFactory(project, options.target, npmPackage)\n    .dry(options.dry ?? false)\n    .onConfirm(options.confirm ?? null)\n    .setLogger(logger);\n\n  // Manually override the target version for codemods if it's explicitly provided\n  if (codemodsTarget !== undefined) {\n    upgrader.overrideCodemodsTarget(codemodsTarget);\n  }\n\n  // Prompt user for confirmation details before upgrading\n  await runUpgradePrompts(upgrader, options);\n\n  // Add specific requirements before upgrading\n  addUpgradeRequirements(upgrader, options);\n\n  // Actually run the upgrade process once configured,\n  // The response contains information about the final status: success/error\n  const upgradeReport = await upgrader.upgrade();\n\n  if (!upgradeReport.success) {\n    throw upgradeReport.error;\n  }\n\n  timer.stop();\n\n  logger.info(`Completed in ${f.durationMs(timer.elapsedMs)}ms`);\n};\n\nconst runUpgradePrompts = async (upgrader: Upgrader, options: UpgradeOptions) => {\n  if (options.target === Version.ReleaseType.Latest) {\n    await prompts.latest(upgrader, options);\n  }\n};\n\nconst addUpgradeRequirements = (upgrader: Upgrader, options: UpgradeOptions): void => {\n  // Don't add the same requirements when manually targeting a major upgrade\n  // using a semver as it's implied that the users know what they're doing\n  if (options.target === Version.ReleaseType.Major) {\n    upgrader\n      .addRequirement(requirements.major.REQUIRE_AVAILABLE_NEXT_MAJOR)\n      .addRequirement(requirements.major.REQUIRE_LATEST_FOR_CURRENT_MAJOR);\n  }\n\n  // Make sure the git repository is in an optimal state before running the upgrade\n  // Mainly used to ease rollbacks in case the upgrade is corrupted\n  upgrader.addRequirement(requirements.common.REQUIRE_GIT.asOptional());\n};\n","import path from 'node:path';\n\nimport { isApplicationProject } from '../../modules/project';\nimport { Version, isSemverInstance, rangeFactory, isRangeInstance } from '../../modules/version';\n\nimport type { Project } from '../../modules/project';\n\nexport const resolvePath = (cwd?: string) => path.resolve(cwd ?? process.cwd());\n\nexport const getRangeFromTarget = (\n  currentVersion: Version.SemVer,\n  target: Version.ReleaseType | Version.LiteralSemVer\n) => {\n  if (isSemverInstance(target)) {\n    return rangeFactory(target);\n  }\n\n  const { major, minor, patch } = currentVersion;\n\n  switch (target) {\n    case Version.ReleaseType.Latest:\n      throw new Error(\"Can't use <latest> to create a codemods range: not implemented\");\n    case Version.ReleaseType.Major:\n      return rangeFactory(`${major}`);\n    case Version.ReleaseType.Minor:\n      return rangeFactory(`${major}.${minor}`);\n    case Version.ReleaseType.Patch:\n      return rangeFactory(`${major}.${minor}.${patch}`);\n    default:\n      throw new Error(`Invalid target set: ${target}`);\n  }\n};\n\nexport const findRangeFromTarget = (\n  project: Project,\n  target: Version.ReleaseType | Version.LiteralSemVer | Version.Range\n): Version.Range => {\n  // If a range is manually defined, use it\n  if (isRangeInstance(target)) {\n    return target;\n  }\n\n  // If the current project is a Strapi application\n  // Get the range from the given target\n  if (isApplicationProject(project)) {\n    return getRangeFromTarget(project.strapiVersion, target);\n  }\n\n  // Else, if the project is a Strapi plugin or anything else\n  // Set the range to match any version\n  return rangeFactory('*');\n};\n","import * as f from '../../modules/format';\nimport { timerFactory } from '../../modules/timer';\nimport { projectFactory } from '../../modules/project';\nimport { codemodRunnerFactory } from '../../modules/codemod-runner';\nimport { findRangeFromTarget, resolvePath } from './utils';\n\nimport type { RunCodemodsOptions } from './types';\nimport type { CodemodRunnerReport } from '../../modules/codemod-runner';\n\nexport const runCodemods = async (options: RunCodemodsOptions) => {\n  const timer = timerFactory();\n  const { logger, uid } = options;\n\n  // Make sure we're resolving the correct working directory based on the given input\n  const cwd = resolvePath(options.cwd);\n\n  const project = projectFactory(cwd);\n  const range = findRangeFromTarget(project, options.target);\n\n  logger.debug(f.projectDetails(project));\n  logger.debug(`Range: set to ${f.versionRange(range)}`);\n\n  const codemodRunner = codemodRunnerFactory(project, range)\n    .dry(options.dry ?? false)\n    .onSelectCodemods(options.selectCodemods ?? null)\n    .setLogger(logger);\n\n  let report: CodemodRunnerReport;\n\n  // If uid is defined, only run the selected codemod\n  if (uid !== undefined) {\n    logger.debug(`Running a single codemod: ${f.codemodUID(uid)}`);\n    report = await codemodRunner.runByUID(uid);\n  }\n\n  // By default, only filter using the specified range\n  else {\n    report = await codemodRunner.run();\n  }\n\n  if (!report.success) {\n    throw report.error;\n  }\n\n  timer.stop();\n\n  logger.info(`Completed in ${timer.elapsedMs}`);\n};\n","import { codemodRepositoryFactory } from '../../modules/codemod-repository';\nimport { projectFactory } from '../../modules/project';\nimport { findRangeFromTarget, resolvePath } from './utils';\n\nimport * as f from '../../modules/format';\n\nimport type { ListCodemodsOptions } from './types';\n\nexport const listCodemods = async (options: ListCodemodsOptions) => {\n  const { logger, target } = options;\n\n  const cwd = resolvePath(options.cwd);\n  const project = projectFactory(cwd);\n  const range = findRangeFromTarget(project, target);\n\n  logger.debug(f.projectDetails(project));\n  logger.debug(`Range: set to ${f.versionRange(range)}`);\n\n  // Create a codemod repository targeting the default location of the codemods\n  const repo = codemodRepositoryFactory();\n\n  // Make sure all the codemods are loaded\n  repo.refresh();\n\n  // Find groups of codemods matching the given range\n  const groups = repo.find({ range });\n\n  // Flatten the groups into a simple codemod array\n  const codemods = groups.flatMap((collection) => collection.codemods);\n\n  // Debug\n  logger.debug(`Found ${f.highlight(codemods.length)} codemods`);\n\n  // Don't log an empty table\n  if (codemods.length === 0) {\n    logger.info(`Found no codemods matching ${f.versionRange(range)}`);\n    return;\n  }\n\n  // Format the list to a pretty table\n  const fCodemods = f.codemodList(codemods);\n\n  logger.raw(fCodemods);\n};\n","import chalk from 'chalk';\n\nimport type { Logger as LoggerInterface, LoggerOptions } from './types';\n\nexport class Logger implements LoggerInterface {\n  isDebug: boolean;\n\n  isSilent: boolean;\n\n  private nbErrorsCalls: number;\n\n  private nbWarningsCalls: number;\n\n  constructor(options: LoggerOptions = {}) {\n    // Set verbosity options\n    this.isDebug = options.debug ?? false;\n    this.isSilent = options.silent ?? false;\n\n    // Initialize counters\n    this.nbErrorsCalls = 0;\n    this.nbWarningsCalls = 0;\n  }\n\n  private get isNotSilent(): boolean {\n    return !this.isSilent;\n  }\n\n  get errors(): number {\n    return this.nbErrorsCalls;\n  }\n\n  get warnings(): number {\n    return this.nbWarningsCalls;\n  }\n\n  get stdout(): (NodeJS.WriteStream & { fd: 1 }) | undefined {\n    return this.isSilent ? undefined : process.stdout;\n  }\n\n  get stderr(): (NodeJS.WriteStream & { fd: 2 }) | undefined {\n    return this.isSilent ? undefined : process.stderr;\n  }\n\n  setDebug(debug: boolean): this {\n    this.isDebug = debug;\n    return this;\n  }\n\n  setSilent(silent: boolean): this {\n    this.isSilent = silent;\n    return this;\n  }\n\n  debug(...args: unknown[]): this {\n    const isDebugEnabled = this.isNotSilent && this.isDebug;\n\n    if (isDebugEnabled) {\n      console.log(chalk.cyan(`[DEBUG]\\t[${nowAsISO()}]`), ...args);\n    }\n\n    return this;\n  }\n\n  error(...args: unknown[]): this {\n    this.nbErrorsCalls += 1;\n\n    if (this.isNotSilent) {\n      console.error(chalk.red(`[ERROR]\\t[${nowAsISO()}]`), ...args);\n    }\n\n    return this;\n  }\n\n  info(...args: unknown[]): this {\n    if (this.isNotSilent) {\n      console.info(chalk.blue(`[INFO]\\t[${new Date().toISOString()}]`), ...args);\n    }\n\n    return this;\n  }\n\n  raw(...args: unknown[]): this {\n    if (this.isNotSilent) {\n      console.log(...args);\n    }\n\n    return this;\n  }\n\n  warn(...args: unknown[]): this {\n    this.nbWarningsCalls += 1;\n\n    if (this.isNotSilent) {\n      console.warn(chalk.yellow(`[WARN]\\t[${new Date().toISOString()}]`), ...args);\n    }\n\n    return this;\n  }\n}\n\nconst nowAsISO = () => new Date().toISOString();\n\nexport const loggerFactory = (options: LoggerOptions = {}) => new Logger(options);\n","import type { Codemod } from '../codemod';\n\nimport type { CodemodReport, Report } from './types';\n\nexport const codemodReportFactory = (codemod: Codemod.Codemod, report: Report): CodemodReport => ({\n  codemod,\n  report,\n});\n\nexport const reportFactory = (report: Report): Report => ({ ...report });\n"],"names":["path","chalk","version","reports","CliTable3","index","timerConstants.ONE_SECOND_MS","ReleaseType","semver","Version.ReleaseType","constants.NPM_REGISTRY_URL","assert","fastglob","jscodeshift","cloneDeep","get","has","merge","set","omit","fse","isEqual","register","module","constants.PROJECT_JSON_EXTENSIONS","constants.PROJECT_CODE_EXTENSIONS","constants.PROJECT_PACKAGE_JSON","constants.PROJECT_APP_ALLOWED_ROOT_PATHS","constants.PROJECT_ALLOWED_EXTENSIONS","constants.STRAPI_DEPENDENCY_NAME","isValidSemVer","constants.PROJECT_PLUGIN_ALLOWED_ROOT_PATHS","constants.PROJECT_PLUGIN_ROOT_FILES","constants.CODEMOD_EXTENSION","constants.CODEMOD_CODE_SUFFIX","constants.CODEMOD_JSON_SUFFIX","constants.CODEMOD_FILE_REGEXP","constants.CODEMOD_ALLOWED_SUFFIXES","codemodRepositoryConstants.INTERNAL_CODEMODS_DIRECTORY","f.reports","f.highlight","successReport","erroredReport","codemods","f.versionRange","groupBy","size","f.version","f.upgradeStep","projectConstants.SCOPED_STRAPI_PACKAGE_PREFIX","packageManager","simpleGit","f.projectDetails","upgraderConstants.STRAPI_PACKAGE_NAME","f.durationMs","prompts.latest","requirements.major.REQUIRE_AVAILABLE_NEXT_MAJOR","requirements.major.REQUIRE_LATEST_FOR_CURRENT_MAJOR","requirements.common.REQUIRE_GIT","f.codemodUID","f.codemodList"],"mappings":"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"}